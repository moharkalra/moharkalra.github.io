<!--



-->





<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Tunetable</title>
  <meta name="description" content="Portfolio">
  <meta name="author" content="Mohar Kalra">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="https://fonts.googleapis.com/css?family=Abel" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Satisfy" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Quicksand" rel="stylesheet">


  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
<link rel="stylesheet" href="css/style3.css">


  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<!--  <link rel="icon" type="image/png" href="images/favicon.png">-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="https://code.jquery.com/jquery-1.10.2.js"></script>



  </head>
  <body>



        <div  class = "nav">
    <div class = "container">
      <div class = "three columns ">
          <a href="index.html#about" class = "big" >ABOUT</a>

      </div>
    <div class = "three columns ">
        <a href="index.html#tech1" class = "big">TECH</a>

    </div>
    <div class = "three columns ">
        <a href="index.html#ad"  class = "big">ART</a>

    </div>
    <div class = "three columns">
        <a href="index.html#contact"  class = "big">CONTACT</a>

    </div>
    </div>
    </div>



<div id = "about" class = "about">
  <span  class = " sec">
          <h3>TuneTable</h3>
    <div class = "row bout">
      <div class = "six columns">
        <div class = "me">
          <h4>Background</h4>
          <p>As a student researcher at Georgia Tech’s Adaptive Digital Media Lab, I worked on the TuneTable project. The TuneTable, designed to be an interactive museum installation, is a large table with graphics projected onto the surface. On the tabletop are several tangible elements that children work in groups to arrange and connect with each other. Different combinations of tangibles are detected by the table and the table plays music according to the children’s arrangements. The logic behind the arrangement of tangibles is based in computational principles, providing children an engaging introduction to computation. Some tangibles are music samples, which, when placed next to each other, play in succession, and other tangibles are modifiers, modifying the quality of the samples. </p>
      </div>
      </div>

    <div class = "six columns">
      <div class = "me">
        <h4>Objective</h4>
          <p>When I joined the TuneTable team, we were in the process of completely overhauling the interaction design of the table. As such, I helped brainstorm ways to improve the table’s interaction schema. Primarily, though, I was responsible for integrating various electronic functions into the tangible elements of the table. I installed wifi communication capabilities into the tangibles, along with various additional sensory inputs and a system of passive communication between tangibles to allow the tangibles to locate each other.</p>
    </div>
    </div>
  </div>
</span>
</div>



      <div class = "row comic">




          <h4>Wi-fi Communication and Sensor Integration:</h4>
            <ul >
                <p>Task:</p><li>Increase user inputs to the table by installing sensors onto tangibles</li><li>
                Install wireless communication module onto tangibles to convey sensor data to table computer</li><li>
                Program server and client onto both tangibles and computer to facilitate wireless communication.</li>
              <p>Parameters:</p><li>Compact electrical design</li><li>
              Arduino-compatible</li><li>
              Rapid and reliable wireless communication to prevent latency in interaction</li><li>
              Table computer and tangibles capable of both sending and receiving signals</li><li>
              Minimize cost of assembly</li><li>
              Maximize modes of user interaction</li>


              <p>Process:</p>
                <li>Wifi communication rather than bluetooth to offer quicker data transfer</li><li>
                Speed of communication is crucial to ensure user interaction sparks immediate table response </li><li>
                Initially, connected Arduino Nano to ESP8266 ESP-01 Wifi Module and Sparkfun APDS-9960 </li><li>
                APDS-9960 detects simple gestures, color, ambient light, and proximity (offers theremin-like user interaction with the tangible)</li><li>
                ESP8266 units ordered lack necessary firmware to be flashable.</li><li>
                Replaced ESP8266 ESP-01 and arduino nano combination with ESP8266 ESP-12E module.</li><li>
                ESP-12E to function as both processor and wifi module, making circuit more compact.</li>


              <p>Solution:</p><li>ESP8266 ESP-12E connected to APDS-9960 sensor board and LED as illustrated above</li><li>

              Wrote python script to serve as server/client for TuneTable computer to send/receive signals from ESP-12E over OSC protocol</li><li>
              Arduino code on ESP-12E also offers OSC server and client functionality</li><li>
              See code for tangible and TuneTable computer below.</li>
            </ul>

            <div class = "sec1">
                <p>ESP-12E connected to APDS-9960:</p>

              <img class = "pic" src="IMG_2916.JPG" style = "width:70%; height:auto; padding-top: 20px;padding-bottom:20px;">

            </div>




<p>Code loaded onto ESP-12E to offer OSC server and client functionality:</p>
<div class = "code">
  <pre>
      #include <SparkFun_APDS9960.h>//Library for the test sensor used

      //Test code to send and receive messages over wifi using OSC protocol from the Esp12-e module
      #include &lt;ESP8266WiFi.h&gt;
      #include &lt;WiFiUdp.h&gt;
      #include &lt;OSCMessage.h&gt;
      #include &lt;OSCBundle.h&gt;
      #include &lt;OSCData.h&gt;
      #include &lt;Wire.h&gt;

      int mag1 = 14;
      int mag2 = 13;
      int mag3 = 2;
      int mag4 = 0;
      int pwm = 4;
      int counter = 0;
      int avg = 0;

      int LED_PIN = 15;
      // Global Variables
      SparkFun_APDS9960 apds = SparkFun_APDS9960();
      uint8_t proximity_data = 0;
      //Wifi setup
      char ssid[] = "GTother";          // your network SSID (name)
      char pass[] = "GeorgeP@1927";         // your network password

      WiFiUDP Udp;                                // A UDP instance to let us send and receive packets over UDP


      const IPAddress outIp(143, 215, 110, 250);        // remote IP of your computer

      //this should match the port to listen on in the python sketch
      const unsigned int outPort = 9999;          // remote port to receive OSC
      const unsigned int localPort = 8888;        // local port to listen for OSC packets (actually not used for sending)
      OSCErrorCode error;
      void setup() {
        pinMode(LED_PIN, OUTPUT);
        analogWrite(LED_PIN, 0);
        Serial.begin(115200);
        pinMode(mag1, INPUT);
        pinMode(mag2, INPUT);
        pinMode(mag3, INPUT);
        pinMode(mag4, INPUT);
        pinMode(pwm, INPUT);
        Wire.begin(6, 5);
        // Connect to WiFi network
        Serial.println();
        Serial.println();
        Serial.print("Connecting to ");
        Serial.println(ssid);
        WiFi.begin(ssid, pass);

        //wait until connected
        while (WiFi.status() != WL_CONNECTED) {
          delay(500);
          Serial.print(".");
        }
        Serial.println("");

        Serial.println("WiFi connected");
        Serial.println("IP address: ");
        Serial.println(WiFi.localIP());

        Serial.println("Starting UDP");
        Udp.begin(localPort);
        Serial.print("Local port: ");
        Serial.println(Udp.localPort());


        //Set up gesture sensor
        if ( apds.init() ) {
          Serial.println(F("APDS-9960 initialization complete"));
        } else {
          Serial.println(F("Something went wrong during APDS-9960 init!"));
        }

        // Adjust the Proximity sensor gain
        if ( !apds.setProximityGain(PGAIN_2X) ) {
          Serial.println(F("Something went wrong trying to set PGAIN"));
        }

        // Start running the APDS-9960 proximity sensor (no interrupts)
        if ( apds.enableProximitySensor(false) ) {
          Serial.println(F("Proximity sensor is now running"));
        } else {
          Serial.println(F("Something went wrong during sensor init!"));
        }


      }


      void loop() {

        if ( !apds.readProximity(proximity_data) ) {
          Serial.println("Error reading proximity value");
        } else {
          Serial.print("Proximity: ");
          Serial.println(proximity_data);
        }



        int button_state = proximity_data / 3;
        int state1 = digitalRead(mag1);
        int state2 = digitalRead(mag2);
        int state3 = digitalRead(mag3);
        int state4 = digitalRead(mag4);
        int pwmval = pulseIn(pwm, HIGH) + pulseIn(pwm, LOW);

        if(counter == 10){
          avg = avg/counter;
          avg = 0;
          counter = 0;
        }
        else if(counter&lt;10){
          avg = avg+pwmval;
          counter = counter+1;
        }

        //Send and receive message functionality is below
        Serial.println("sending message...");

        /* This is the address of the message.
        You can use this to distinguish between the
        different values that you send. For example
        you could have /button, /accel-x, /gyro-x, etc
        for different sensors.
        */
        OSCMessage msg("/value");

        /* add data to the message. Any data type works.
        For example, msg.add("hi"); would also work

        */
        msg.add(button_state);

        //send out the msg over udp
        Udp.beginPacket(outIp, outPort);
        msg.send(Udp);
        Udp.endPacket();
        msg.empty();

        OSCMessage msg1;
        //get the data from the network
        int size = Udp.parsePacket();

        //only do stuff if we actually got data
        if (size &gt; 0) {
          while (size--) {
            /*
            if your client was sending an osc bundle
            instead of a message, this line would be:
            bundle.fill(Udp.read());
            */
            msg1.fill(Udp.read());
          }

          if (!msg1.hasError()) {
            /* if the bundle has a message with the
            address "/led", call the function led.
            If the message that the client is sending
            does not have this address, the NodeMCU
            wont do anything.
            */
            msg1.dispatch("/led", led);
            Serial.println("Message Received!");
            /* If you are also sending a separate message that has
            the address "/motor", you could do something
            with it here.
            */
            //msg1.dispatch("/motor", motor_function);
          } else {
            error = msg1.getError();
            Serial.print("error: ");
            Serial.println(error);
          }
        }


        delay(100);
      }
      void led(OSCMessage &msg) {
        // check if the first piece of data is an int and if so, use it
        if (msg.isInt(0)) {
          int ledState = msg.getInt(0);
          Serial.println("LED" + ledState);
          analogWrite(LED_PIN, ledState * 3);
          Serial.print("/led: ");
          Serial.println(ledState);
        }

      }</pre>

    </div>

    <p style = "padding-top: 20px;">Python script on TuneTable computer to offer OSC server and client functionality:</p>
    <div class = "code">
      <pre>
        import argparse
        import math

        from pythonosc import dispatcher
        from pythonosc import osc_server
        import random
        import time

        from pythonosc import osc_bundle_builder
        from pythonosc import osc_message_builder
        from pythonosc import udp_client

        #Test code to set up a python server and client that communicates over wifi with the ESP-12e module using OSC protocol
        def  printButton(unused_addr, data):
        print ("message received")
        print("sending msg: " + str(data))

        #  - if you wanted to send a bundle, you could use:
        #       bundle = osc_bundle_builder.OscBundleBuilder(osc_bundle_builder.IMMEDIATELY)
        #       {build your message and add data to it like you do below}
        #       bundle.add_content(msg1)
        #       bundle.add_content(msg2)
        #       bundle = bundle.build()
        #       client.sen(bundle)

        # build the msg to send to the NodeMCU. This is the address that
        # the NodeMCU will be watching for
        msg = osc_message_builder.OscMessageBuilder(address = "/led")

        # add the data to the message
        msg.add_arg(data)
        msg = msg.build()

        #send the message
        client1.send(msg)
        print("message sent");


        if __name__ == "__main__":

        CompIP = "143.215.110.250";#Computer IP
        ESPIP = "143.215.102.99"; #ESP12e IP address - this will be printed out by the ESP12e when it initializes using the test code ESP8266ServerClient.ino
        # This should match the outPort in the Arduino sketch
        port = 9999 #Server port
        port1 = 8888; #Client port
        #server receives messages. Client (1's) send messages.
        #All variables with '1' in their names refer to client functionality

        parser = argparse.ArgumentParser()
        parser.add_argument("--ip", default=CompIP, help="The ip to listen on")
        parser.add_argument("--port", type=int, default=port,
        help="The port to listen on")
        args = parser.parse_args()

        # set up the dispatcher to handle the osc
        dispatcher = dispatcher.Dispatcher()



        dispatcher.map("/value", printButton)
        # Start the server to recieve osc
        server = osc_server.ThreadingOSCUDPServer(
        (args.ip, args.port), dispatcher)
        print("Serving on {}".format(server.server_address))
        parser1 = argparse.ArgumentParser()
        parser1.add_argument("--ip", default=ESPIP, help="The ip of the OSC server")
        parser1.add_argument("--port", type=int, default=port1, help="The port the OSC server is listening on")
        args1 = parser1.parse_args()

        # set up udp client
        client1 = udp_client.UDPClient(args1.ip, args1.port)







        server.serve_forever()

      </pre>
    </div>

            <h4 style = "padding-top: 20px;">Passive Sensing</h4>
              <ul >
                  <p>Task:</p><li>Obviate need for touchscreen table top to locate tangibles’ location by using passive communication system between tangibles</li><li>
                  Three tiers of tangibles - core tier contains sound samples and communicates with table, second and third tiers modify core samples</li>
                  <li>Table divided into eighths, each with sound sample and modifiers</li>
                  <li>Table plays each eighth in sequence as a loop</li>
                <p>Parameters:</p><li>Enable one tangible to passively convey which other tangibles are connected to it</li><li>
                Communicate between core ring of tangibles and TuneTable computer which tangibles are connected to which</li><li>
                Instantaneous and high fidelity communication</li>

                <p>Process:</p>
                  <li>Designed system of magnets and hall effect sensors on tangibles</li><li>
                  Each second tier tangible equipped with combination of two magnets. </li><li>
                  Designed prototypical tangible stand-ins with magnets stuck on</li><li>
                  Two Hall effect sensors on second and core tier circuits detect magnetic ID of nearby tangibles</li><li>
                  Third tier tangibles equipped only with magnetic ID’s</li><li>
                  Second tier tangibles equipped with ATTiny84’s to process and transmit information to core tangibles</li><li>
                  Core tangibles contain ESP-12E’s to communicate with table computer</li><li>
                  Idea scrapped</li>
                  <ul><li>
                  Each tangible needs to identify 16+ potential other combinations of tangibles</li><li>
                  Magnet ID’s are space inefficient</li><li>
                  Magnet ID’s unable to vary to convey to core tangibles which combinations of second and third tier tangibles are attached</li></ul><li>
                  Devised system of contact pads on each tangible which convey PWM signal, identifying the tangible and those attached</li><li>
                  Contact between two tangibles' contact pads completes circuit between tangibles and enables power/data to be transferred</li><li>
                  Idea scrapped</li><ul><li>
                   PWM signals too inconsistent to accurately interpret</li></ul><li>
                  Designed system where contact pads between tangibles transmit identifying codes using serial protocol instead of PWM</li><li>
                  Serial signals lack fidelity</li><li>
                  Final system uses I2C between third, second and core tier tangibles to communicate</li>

                  <div class = "sec1">
                      <p>Serial connection between ATTiny 84 and Arduino Nano</p>

                    <img class = "pic2" src="IMG_2923.JPG" style = "width:70%; height:auto; padding-top: 20px;padding-bottom: 20px;">

                  </div>
                  <div class = "sec1">
                      <p>Circuit Diagram for Serial connection</p>

                    <img class = "pic" src="Serial.jpeg" style = "width:100%; height:auto;">

                  </div>



                <p>Solution:</p><li>Four contact pads on Third tier tangibles - GND, VIN, SDA, SCL</li><li>
                Eight contact pads on second tier tangibles</li><ul><li>
                   GND, VIN, SDA, SCL to power third tier tangibles and receive data from them</li><li>
                    GND, VIN, SDA, SCL to communicate with core tangibles</li></ul><li>
                All tiers of tangibles powered by ATTiny 84</li><li>
                Core tier communicates with TuneTable computer through console in table center - no need for wireless communication</li><li>
                See Diagram Below for tangible arrangement</li><li>
                ATTiny’s communicate over I2C when powered (see I2C master/slave test code below) by contact with other tangibles</li><li>
                Arduino in TuneTable console coordinates and powers all tangibles</li>

                <div class = "sec1">
                    <p>Diagram of the tabletop, the tiers and the signals between each tangible:</p>

                  <img class = "pic" src="TuneTableLayout.jpg" style = "width:100%; height:auto;">

                </div>

                <div class = "sec1">
                    <p>Prototypical I2C connection between ATTiny 84 and Arduino Nano</p>

                  <img class = "pic2" src="IMG_2971.JPG" style = "width:70%; height:auto;  padding-top: 20px;padding-bottom: 20px;">

                </div>
                <div class = "sec1">
                    <p>Circuit Diagram for I2C connection</p>

                  <img class = "pic" src="I2C.jpeg" style = "width:100%; height:auto;">

                </div>



              </ul>


  <p style = "padding-top: 20px;">I2C Slave Test Code on each ATTiny 84:</p>
    <div class = "code">
      <pre>
          //Test code for I2C slave functionality on ATTiny84

          #define SLAVE_ADDR 0x8 //ATTiny's address. Must be same as address in Master Sketch

          #include <TinyWireS.h> // Must always come after address declaration above

          const int mag1 = 2;
          const int mag2 = 3;
          const int led1 = 0;
          const int led2 = 1;


          //Make sure to connect the arduino and tiny to a common ground.
          //Tiny GPIO 4 to Arduino A5
          //Tiny GPIO 6 to Arduino A4

          void setup()
          {
            //Stes up Hall effect and LED's for test setup
            pinMode(led1, OUTPUT);
            pinMode(led2, OUTPUT);
            pinMode(mag1, INPUT);
            pinMode(mag2, INPUT);
            TinyWireS.begin(SLAVE_ADDR);
            TinyWireS.onRequest(requestEvent); //When Master requests data, call function requestEvent
          }


          void loop()
          {

            //Turns LED's on or off depending on state of hall effect sensors. Hall effect sensors are active low.
            if(digitalRead(mag1) == 0){
              digitalWrite(led1, HIGH);
            }
            else{
              digitalWrite(led1, LOW);
            }
            if(digitalRead(mag2) == 0){
              digitalWrite(led2, HIGH);
            }
            else{
              digitalWrite(led2, LOW);
            }
            delay(100);
          }

          void requestEvent()
          {
            //Sends a different character to the master depending on the state of the Hall effect sensors
            if(digitalRead(mag1) == 0 && digitalRead(mag2) == 0){
              TinyWireS.send("1");
            }
            else if(digitalRead(mag1) == 0 && digitalRead(mag2) == 1){
              TinyWireS.send("2");
            }
            else if(digitalRead(mag1) == 1 && digitalRead(mag2) == 0){
              TinyWireS.send("3");
            }
            else{
              //If no sensors are triggered, the value "4" is sent.
              TinyWireS.send("4");
            }


          }


        </pre>
      </div>

    <p style = "padding-top: 20px;">I2C Master Test Code on Arduino Nano:</p>
    <div class = "code">
      <pre>
        #include <Wire.h>
          //I2C Master code on arduino nano
          void setup() {
            Wire.begin();        // join i2c bus (address optional for master)
            Serial.begin(9600);  // start serial for output
          }

          void loop() {
            Wire.requestFrom(0X8, 1);    // request 1 byte from slave device 0X8

            while (Wire.available()) { // slave may send less than requested
              char c = Wire.read(); // receive a byte as character
              Serial.println(c);         // print the character
            }

            delay(100);
          }
        </pre>
      </div>
    </div>






<div id = "end">


    <div class = "cp">
      <p>
        &copy; 2019 all rights reserved Mohar Kalra.
      </p>

  </div>
</div>


  <!-- End Document
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  </body>

  </html>
